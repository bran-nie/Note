# 极客时间：浏览器工作原理与实践

## 第一讲：

-   进程、线程

    -   一个进程就是一个程序的运行实例
    -   启动一个程序时，操作系统会为该程序**创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程**，这样的一个运行环境就是一个进程。
    -   线程执行出错会导致该线程所属的进程崩溃。
    -   线程之间会共享进程中的数据。
    -   当一个进程关闭之后，操作系统会回收进程所占用的内存。
    -   进程之间相互隔离。

-   曾经单进程架构的浏览器

    -   不稳定：早期浏览器不少功能实现是借助插件来实现的，如 Web 视频、Web 游戏等功能，如果插件出问题，则会造成浏览器的崩溃
    -   不流畅：由于页面的网络请求模块、渲染模块、js 执行环境以及插件模块都是运行在一个线程中，那么相互之间就会抢占资源，同时只有一个模块会执行。
    -   不安全：插件可以用 C/C++编写，通过插件可以获取到系统的任意资源，运行插件时，插件是拥有操作权限的，那么可能会释放病毒、窃取个人信息等。

-   现在多进程架构

    -   解决不稳定问题：由于进程之间相互隔离，一个页面或者插件崩溃时，不会影响别的
    -   解决不流畅问题：由于页面之间相互隔离，即使一个页面的 js 执行阻塞了渲染进程，也只是阻塞该页面，而不会影响其他页面，关闭一个页面时，页面相关的进程也会关闭，其占用的内存都会被系统回收。
    -   解决不安全问题：使用安全沙箱，程序只能在沙箱中执行，不能访问沙箱外部的环境。

-   Chrome 架构：
    -   打开一个页面会有几个进程
        -   浏览器主进程
        -   网络进程
        -   渲染进程
        -   GPU 进程
        -   插件进程（如果有安装插件

## 第二讲：

-   Web 页面性能重要指标

    -   FP（First Paint）从页面加载到首次开始绘制的时长
        -   影响：用户的跳出率
        -   更快的页面响应意味着 更多的 PV、更高的参与度，以及更高的转化率。
        -   影响 FP 指标的其中一个重要因素：网络加载速度

-   一个数据包的旅行
    -   网络之间通过协议进行旅行
        -   互联网，实际上是通过一套理念和协议组成的体系架构
    -   IP 协议：把数据包送达目的地
        -   计算机的地址就称为 IP 地址，访问任何网站实际上就是你的计算机向另一台计算机请求信息
        -   数据包从主机 A 到主机 B
            -   将数据包交给网络层
            -   网络层将 IP 头附加到数据包，组成新的 **IP 数据包**，交给底层
            -   底层通过物理网络将 IP 数据包传输给主机 B
            -   主机 B 的网络层接收到 IP 数据包，主机 B 拆分出 IP 头信息后，将数据包交给上层
        -   这里就是三层结构：上层、网络层、底层。
        -   示意图
            ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211182204.png)
    -   UDP 协议：把数据包送到应用程序
        -   IP 协议只负责把数据从 A 到 B，但并不知道数据是要 B 中哪个程序处理，故需要再在 IP 协议之上增加一个协议：UDP，能与应用打交道的协议
        -   用户数据包协议，User Datagram Protocol，简称 UDP
        -   UDP 中一个最重要的信息是**端口号**。通过端口号就能把指定的数据包发给指定的程序了。
            -   端口号是一个数字，每一个需要访问网络的程序，都需要绑定一个端口号。
        -   故，UDP 在 IP 协议之上，再增加一个 UDP 头，用来传输端口号。
        -   这里就是四层结构：上层、传输层、网络层、底层。
        -   示意图
            ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211182113.png)
        -   数据包从主机 A 到主机 B
            -   相比 IP 协议的送达，UDP 协议是多了一次包装端口号的 UDP 头和一次解析 UDP 头
        -   UDP 协议的现状：
            -   缺点：
                -   可能出现的各种因素而导致数据包出错，UDP 协议不会重发；
                -   UDP 协议不能保证数据包能发送到目的地；
            -   优点：
                -   传输速度非常快
                -   在一些关注速度不严格要求数据完整性的领域，UDP 更合适，如：在线视频，互动游戏等。
    -   TCP 协议：把数据完整的送到应用程序
        -   对于浏览器请求，或者邮件等这类需要数据可靠性等应用，UDP 协议来传输会有两个问题：
            -   数据包可能会丢失
            -   大的数据包拆分很多小数据包进行传输时，小数据包很可能会在不同的时间到达目的地，即顺序会错乱，UDP 协议不能告诉主机 B 怎么组装数据包。
        -   故，基于这两个问题，又引入了 TCP 协议，
            -   TCP Transmission Control Protocol，传输控制协议
            -   是一种面向连接的、可靠的、基于字节流的传输通信协议。
            -   相比 UDP，TCP 有下面两个特点：
                -   对于丢失的数据包，TCP 提供重传机制
                -   TCP 引入数据包排序机制，用来保证把乱序的数据包组装合成一个完整的数据包。
            -   和 UDP 头一样，TCP 头除了包含本机端口和目标端口号之外，还提供了用户排序的序列号，以便接收端通过序号来重排数据包。
            -   示意图
                ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211182316.png)
        -   数据包从主机 A 到主机 B：
            -   相比 IP 协议的送达，TCP 协议时多了包装/解析端口号和序列号。
        -   但相比 UDP 的传输，TCP 传输是有三个阶段
            -   建立连接：三次握手，
                -   A 告诉 B 要开始连接
                -   B 说知道了，你开始吧
                -   A 说好的。
            -   传输数据
                -   B 会对每个数据包进行确认操作
                -   当 A 发送的某个数据包在规定时间内没有接收到 B 的确认，则判断该数据包丢失，A 会再次发送。
                -   B 会根据 TCP 头中的序列号，对数据包进行组合。
            -   断开连接：四次挥手
                -   A 告诉 B，我传完了，我要断开了
                -   B 说，我知道了，我准备一下断开
                -   B 说，我准备好了，断开吧
                -   A 说，好的，那断开了。
            -   示意图
                ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211182601.png)

## 第三讲：HTTP 请求流程，为什么很多站点第二次打开，速度会很快？

-   HTTP 协议
    -   页面发起的请求是 HTTP 协议请求，是建立在 TCP 连接基础之上的。
    -   HTTP 协议，是一种允许浏览器向服务器获取资源的协议，是 Web 的基础。
    -   HTTP 也是浏览器使用最广的协议
    -   HTTP 是应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上
    -   在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接，也就是说**HTTP 的内容是通过 TCP 的传输数据阶段来实现的**
    -   示意图：
        ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211181917.png)
-   两个问题：
    -   为何第二次打开某个网站，相比第一次打开，速度很快？
    -   为何登录一个网站后，关闭页面，再次打开访问该站点，还是登录状态，怎么做到的？
-   浏览器发起 HTTP 请求流程
    1.  构建请求
        -   构建请求行信息，构建好以后，浏览器准备发起网络请求（网络进程）
        -   `GET /index.html HTTP1.1`
    2.  查找缓存
        -   在真正发起网络请求之前，浏览器先会在浏览器缓存中查询，是否有要请求的文件。
            -   缓存是一种在本地保存的资源副本，这是一个供下次请求时直接使用的技术。
        -   如果有缓存，则会拦截请求，返回该资源的副本，并结束请求，而不会再向服务器重新下载。
            -   缓解服务器压力，提升性能（获取资源更快了）
            -   对于网站来说，缓存是实现资源快速加载的重要组成部分。
        -   如果缓存查询失败，则会进入网络请求过程了。
    3.  准备 IP 地址和端口
        -   HTTP 网络请求的第一步是和服务器建立 TCP 连接
            -   建立 TCP 连接是需要 IP 地址和端口号的
            -   URL 怎么获取 IP 地址和端口号呢？
                -   由于 IP 地址并不好记忆，故基于该需求出现了一个系统：DNS，Domain Name System，域名系统。
                -   因此，浏览器第一步是通过 URL 中的域名，来查询对应的 IP 地址。当然，浏览器也有 DNS 数据缓存，这样可以减少一次网络请求。
                -   端口号呢，通常情况下，如果 URL 没有指明端口号，那么 HTTP 协议的端口号默认是 80 端口，HTTPS 协议的端口号默认是 433 端口。
            -   这就获取到 IP 地址和端口号了
    4.  等待 TCP 队列
        -   Chrome 机制：同一个域名同时最多能建立 6 个 TCP 连接。如果同时有 10 个请求，那么其中 4 个会排队等待，其他 6 个有请求完成的时候，才会开始建立连接
        -   如果少于六个，则进到下一步
    5.  建立 TCP 连接
        -   在 HTTP 工作之前，TCP 已经与服务器建立连接了。
    6.  发起 HTTP 请求
        -   建立 TCP 连接后，浏览器就可以和服务器进行通信了，（是在 TCP 的传输数据阶段）
        -   HTTP 中的数据就是在这个通信过程中传输的。
        -   示意图
            ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211184236.png)
        -   描述：
            -   首先浏览器会向服务器发送**请求行**
                -   请求方法、请求 URI、HTTP 版本协议
            -   请求头形式发送一些其他信息如：
                -   浏览器使用的操作系统、浏览器内核等信息
                -   域名信息，浏览器端的 Cookie 信息
            -   如果是 POST 等需要请求体的请求方法，还会将一些数据放在请求体中发送给服务端
-   服务器端响应处理 HTTP 请求流程：
    1.  返回请求
        -   响应行，包括协议版本和状态码
            -   不是所有的请求都会被服务器处理的，服务器会通过状态码来告诉浏览器，它的处理结果
            -   常用的状态码：200 成功，404，没找到资源，等等
        -   响应头，包含服务器的一些信息
            -   服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等
            -   服务器要在客户端保存的 Cookie 等信息
        -   响应体，请求数据
            -   通常，响应体就包含了请求需要的数据，如 HTML、js、css、图片等资源
    2.  断开连接
        -   通常情况下，一旦服务器向客户端返回了请求数据，就要关闭 TCP 连接了，不过浏览器或者服务器在头信息中加入`Connection: Keep-Alive`，那么 TCP 链接会保持打开状态。
        -   保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。
            -   比如，一个 Web 页面中内嵌的图片都来自同一个站点，如果初始化一个持久连接，那么就可以复用该连接，以请求权其他资源，而不需要重新再建立新的 TCP 连接。
    3.  重定向
        -   当请求的资源的响应行的状态码是 301 等重定向状态码时，就是服务器告诉浏览器，这次请求的资源，需要重新请求，而新的地址，在响应体中的`Location`字段中。
        -   重新请求，就是浏览器获取`Location`中的地址，重新发起地址导航。
        -   重定向这种，是服务器端配置的。
-   问题解答

    -   为什么第二次打开站点速度会很快？
        -   浏览器对资源进行了缓存
        -   DNS 缓存
            -   在浏览器本地将对应的 IP 和域名关联起来
        -   页面资源缓存
            -   缓存示意图
                ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211194032.png)
            -   如何缓存？
                -   第一次请求，没有缓存，请求发送到服务器，返回资源后，通过**响应头中的 Cache-Control 字段来设置是否缓存资源**，通常，还需要设置缓存有效期/时长。
                -   `Cache-Control: Max-age=2000`表示该资源有效期是 2000 秒，在这个有效期内再次请求资源，则会直接返回缓存中的资源给服务器。
                -   如果缓存已经过期了，浏览器会继续发起请求，并在请求头中加上`If-None-Match:"dsd3-adc-adadfad"`，而服务器端会根据该字段判断请求的资源是否更新。
                    -   没有更新，返回 304，缓存可以继续使用
                    -   更新，返回最新数据给客户端。
            -   缓存分协商缓存和强缓存，后面会补充。
    -   登录状态是如何保持的？
        -   通过 Cookie 来实现的。
            ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211194856.png)

    ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211194931.png)

    -   浏览器的 HTTP 请求经历八个阶段。

-   问题：如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？
    -   回答：
        1. 并发请求过多（大于 6），TCP 连接进入等待状态
        2. 资源大，下载时间过长
        3. 对于一些资源的重复请求，TCP 连接没有 connection=keep-alive, 消耗连接时间
        4. 网络慢、连接超时
        5. 网络传输丢包，需要不断重传
