# 极客时间：浏览器工作原理与实践

## 第一讲：

-   进程、线程

    -   一个进程就是一个程序的运行实例
    -   启动一个程序时，操作系统会为该程序**创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程**，这样的一个运行环境就是一个进程。
    -   线程执行出错会导致该线程所属的进程崩溃。
    -   线程之间会共享进程中的数据。
    -   当一个进程关闭之后，操作系统会回收进程所占用的内存。
    -   进程之间相互隔离。

-   曾经单进程架构的浏览器

    -   不稳定：早期浏览器不少功能实现是借助插件来实现的，如 Web 视频、Web 游戏等功能，如果插件出问题，则会造成浏览器的崩溃
    -   不流畅：由于页面的网络请求模块、渲染模块、js 执行环境以及插件模块都是运行在一个线程中，那么相互之间就会抢占资源，同时只有一个模块会执行。
    -   不安全：插件可以用 C/C++编写，通过插件可以获取到系统的任意资源，运行插件时，插件是拥有操作权限的，那么可能会释放病毒、窃取个人信息等。

-   现在多进程架构

    -   解决不稳定问题：由于进程之间相互隔离，一个页面或者插件崩溃时，不会影响别的
    -   解决不流畅问题：由于页面之间相互隔离，即使一个页面的 js 执行阻塞了渲染进程，也只是阻塞该页面，而不会影响其他页面，关闭一个页面时，页面相关的进程也会关闭，其占用的内存都会被系统回收。
    -   解决不安全问题：使用安全沙箱，程序只能在沙箱中执行，不能访问沙箱外部的环境。

-   Chrome 架构：
    -   打开一个页面会有几个进程
        -   浏览器主进程
        -   网络进程
        -   渲染进程
        -   GPU 进程
        -   插件进程（如果有安装插件

## 第二讲：

-   Web 页面性能重要指标

    -   FP（First Paint）从页面加载到首次开始绘制的时长
        -   影响：用户的跳出率
        -   更快的页面响应意味着 更多的 PV、更高的参与度，以及更高的转化率。
        -   影响 FP 指标的其中一个重要因素：网络加载速度

-   一个数据包的旅行
    -   网络之间通过协议进行旅行
        -   互联网，实际上是通过一套理念和协议组成的体系架构
    -   IP 协议：把数据包送达目的地
        -   计算机的地址就称为 IP 地址，访问任何网站实际上就是你的计算机向另一台计算机请求信息
        -   数据包从主机 A 到主机 B
            -   将数据包交给网络层
            -   网络层将 IP 头附加到数据包，组成新的 **IP 数据包**，交给底层
            -   底层通过物理网络将 IP 数据包传输给主机 B
            -   主机 B 的网络层接收到 IP 数据包，主机 B 拆分出 IP 头信息后，将数据包交给上层
        -   这里就是三层结构：上层、网络层、底层。
        -   示意图
            ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211182204.png)
    -   UDP 协议：把数据包送到应用程序
        -   IP 协议只负责把数据从 A 到 B，但并不知道数据是要 B 中哪个程序处理，故需要再在 IP 协议之上增加一个协议：UDP，能与应用打交道的协议
        -   用户数据包协议，User Datagram Protocol，简称 UDP
        -   UDP 中一个最重要的信息是**端口号**。通过端口号就能把指定的数据包发给指定的程序了。
            -   端口号是一个数字，每一个需要访问网络的程序，都需要绑定一个端口号。
        -   故，UDP 在 IP 协议之上，再增加一个 UDP 头，用来传输端口号。
        -   这里就是四层结构：上层、传输层、网络层、底层。
        -   示意图
            ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211182113.png)
        -   数据包从主机 A 到主机 B
            -   相比 IP 协议的送达，UDP 协议是多了一次包装端口号的 UDP 头和一次解析 UDP 头
        -   UDP 协议的现状：
            -   缺点：
                -   可能出现的各种因素而导致数据包出错，UDP 协议不会重发；
                -   UDP 协议不能保证数据包能发送到目的地；
            -   优点：
                -   传输速度非常快
                -   在一些关注速度不严格要求数据完整性的领域，UDP 更合适，如：在线视频，互动游戏等。
    -   TCP 协议：把数据完整的送到应用程序
        -   对于浏览器请求，或者邮件等这类需要数据可靠性等应用，UDP 协议来传输会有两个问题：
            -   数据包可能会丢失
            -   大的数据包拆分很多小数据包进行传输时，小数据包很可能会在不同的时间到达目的地，即顺序会错乱，UDP 协议不能告诉主机 B 怎么组装数据包。
        -   故，基于这两个问题，又引入了 TCP 协议，
            -   TCP Transmission Control Protocol，传输控制协议
            -   是一种面向连接的、可靠的、基于字节流的传输通信协议。
            -   相比 UDP，TCP 有下面两个特点：
                -   对于丢失的数据包，TCP 提供重传机制
                -   TCP 引入数据包排序机制，用来保证把乱序的数据包组装合成一个完整的数据包。
            -   和 UDP 头一样，TCP 头除了包含本机端口和目标端口号之外，还提供了用户排序的序列号，以便接收端通过序号来重排数据包。
            -   示意图
                ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211182316.png)
        -   数据包从主机 A 到主机 B：
            -   相比 IP 协议的送达，TCP 协议时多了包装/解析端口号和序列号。
        -   但相比 UDP 的传输，TCP 传输是有三个阶段
            -   建立连接：三次握手，
                -   A 告诉 B 要开始连接
                -   B 说知道了，你开始吧
                -   A 说好的。
            -   传输数据
                -   B 会对每个数据包进行确认操作
                -   当 A 发送的某个数据包在规定时间内没有接收到 B 的确认，则判断该数据包丢失，A 会再次发送。
                -   B 会根据 TCP 头中的序列号，对数据包进行组合。
            -   断开连接：四次挥手
                -   A 告诉 B，我传完了，我要断开了
                -   B 说，我知道了，我准备一下断开
                -   B 说，我准备好了，断开吧
                -   A 说，好的，那断开了。
            -   示意图
                ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211182601.png)

## 第三讲：HTTP 请求流程，为什么很多站点第二次打开，速度会很快？

-   HTTP 协议
    -   页面发起的请求是 HTTP 协议请求，是建立在 TCP 连接基础之上的。
    -   HTTP 协议，是一种允许浏览器向服务器获取资源的协议，是 Web 的基础。
    -   HTTP 也是浏览器使用最广的协议
    -   HTTP 是应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上
    -   在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接，也就是说**HTTP 的内容是通过 TCP 的传输数据阶段来实现的**
    -   示意图：
        ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211181917.png)
-   两个问题：
    -   为何第二次打开某个网站，相比第一次打开，速度很快？
    -   为何登录一个网站后，关闭页面，再次打开访问该站点，还是登录状态，怎么做到的？
-   浏览器发起 HTTP 请求流程
    1.  构建请求
        -   构建请求行信息，构建好以后，浏览器准备发起网络请求（网络进程）
        -   `GET /index.html HTTP1.1`
    2.  查找缓存
        -   在真正发起网络请求之前，浏览器先会在浏览器缓存中查询，是否有要请求的文件。
            -   缓存是一种在本地保存的资源副本，这是一个供下次请求时直接使用的技术。
        -   如果有缓存，则会拦截请求，返回该资源的副本，并结束请求，而不会再向服务器重新下载。
            -   缓解服务器压力，提升性能（获取资源更快了）
            -   对于网站来说，缓存是实现资源快速加载的重要组成部分。
        -   如果缓存查询失败，则会进入网络请求过程了。
    3.  准备 IP 地址和端口
        -   HTTP 网络请求的第一步是和服务器建立 TCP 连接
            -   建立 TCP 连接是需要 IP 地址和端口号的
            -   URL 怎么获取 IP 地址和端口号呢？
                -   由于 IP 地址并不好记忆，故基于该需求出现了一个系统：DNS，Domain Name System，域名系统。
                -   因此，浏览器第一步是通过 URL 中的域名，来查询对应的 IP 地址。当然，浏览器也有 DNS 数据缓存，这样可以减少一次网络请求。
                -   端口号呢，通常情况下，如果 URL 没有指明端口号，那么 HTTP 协议的端口号默认是 80 端口，HTTPS 协议的端口号默认是 433 端口。
            -   这就获取到 IP 地址和端口号了
    4.  等待 TCP 队列
        -   Chrome 机制：同一个域名同时最多能建立 6 个 TCP 连接。如果同时有 10 个请求，那么其中 4 个会排队等待，其他 6 个有请求完成的时候，才会开始建立连接
        -   如果少于六个，则进到下一步
    5.  建立 TCP 连接
        -   在 HTTP 工作之前，TCP 已经与服务器建立连接了。
    6.  发起 HTTP 请求
        -   建立 TCP 连接后，浏览器就可以和服务器进行通信了，（是在 TCP 的传输数据阶段）
        -   HTTP 中的数据就是在这个通信过程中传输的。
        -   示意图
            ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211184236.png)
        -   描述：
            -   首先浏览器会向服务器发送**请求行**
                -   请求方法、请求 URI、HTTP 版本协议
            -   请求头形式发送一些其他信息如：
                -   浏览器使用的操作系统、浏览器内核等信息
                -   域名信息，浏览器端的 Cookie 信息
            -   如果是 POST 等需要请求体的请求方法，还会将一些数据放在请求体中发送给服务端
-   服务器端响应处理 HTTP 请求流程：
    1.  返回请求
        -   响应行，包括协议版本和状态码
            -   不是所有的请求都会被服务器处理的，服务器会通过状态码来告诉浏览器，它的处理结果
            -   常用的状态码：200 成功，404，没找到资源，等等
        -   响应头，包含服务器的一些信息
            -   服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等
            -   服务器要在客户端保存的 Cookie 等信息
        -   响应体，请求数据
            -   通常，响应体就包含了请求需要的数据，如 HTML、js、css、图片等资源
    2.  断开连接
        -   通常情况下，一旦服务器向客户端返回了请求数据，就要关闭 TCP 连接了，不过浏览器或者服务器在头信息中加入`Connection: Keep-Alive`，那么 TCP 链接会保持打开状态。
        -   保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。
            -   比如，一个 Web 页面中内嵌的图片都来自同一个站点，如果初始化一个持久连接，那么就可以复用该连接，以请求权其他资源，而不需要重新再建立新的 TCP 连接。
    3.  重定向
        -   当请求的资源的响应行的状态码是 301 等重定向状态码时，就是服务器告诉浏览器，这次请求的资源，需要重新请求，而新的地址，在响应体中的`Location`字段中。
        -   重新请求，就是浏览器获取`Location`中的地址，重新发起地址导航。
        -   重定向这种，是服务器端配置的。
-   问题解答

    -   为什么第二次打开站点速度会很快？
        -   浏览器对资源进行了缓存
        -   DNS 缓存
            -   在浏览器本地将对应的 IP 和域名关联起来
        -   页面资源缓存
            -   缓存示意图
                ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211194032.png)
            -   如何缓存？
                -   第一次请求，没有缓存，请求发送到服务器，返回资源后，通过**响应头中的 Cache-Control 字段来设置是否缓存资源**，通常，还需要设置缓存有效期/时长。
                -   `Cache-Control: Max-age=2000`表示该资源有效期是 2000 秒，在这个有效期内再次请求资源，则会直接返回缓存中的资源给服务器。
                -   如果缓存已经过期了，浏览器会继续发起请求，并在请求头中加上`If-None-Match:"dsd3-adc-adadfad"`，而服务器端会根据该字段判断请求的资源是否更新。
                    -   没有更新，返回 304，缓存可以继续使用
                    -   更新，返回最新数据给客户端。
            -   缓存分协商缓存和强缓存，后面会补充。
    -   登录状态是如何保持的？
        -   通过 Cookie 来实现的。
            ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211194856.png)

    ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220211194931.png)

    -   浏览器的 HTTP 请求经历八个阶段。

-   问题：如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？
    -   回答：
        1. 并发请求过多（大于 6），TCP 连接进入等待状态
        2. 资源大，下载时间过长
        3. 对于一些资源的重复请求，TCP 连接没有 connection=keep-alive, 消耗连接时间
        4. 网络慢、连接超时
        5. 网络传输丢包，需要不断重传
        6. 检查客户端网络状况

## 第四、五讲：从输入 URL 到页面展示，这中间发生了什么？

![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220213150720.png)
由图可知，**整个过程需要各个进程之间相互配合**

-   各个进程的主要职责
    -   浏览器主进程，主要负责用户交互，子进程管理和文件存储等功能
    -   网络进程，是面向渲染进程和浏览器主进程等进程提供网络下载功能
    -   渲染进程，主要是把获取到的资源，进行解析渲染
        -   因为渲染进程所有的内容都是通过网络获取的，可能会存在恶意代码，所以运行在渲染进程里面的代码是不被信任的。这也是为什么在 Chrome 中，渲染进程是在安全沙箱里面运行。
-   结合图中的流程，用文字描述这个过程
    -   首先，浏览器主进程处理用户的输入，待输入完成(回车)后，浏览器进程便将该 URL 转发给网络进程
    -   在网络进程中发起真正的 URL 请求
    -   网络进程接收到响应头数据，便解析响应头数据，并将数据转发给浏览器进程
    -   浏览器进程接收到网络进程的数据后，发送“提交导航”消息到渲染进程
    -   渲染进程接收到“提交导航”消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道
    -   最后渲染进程会向浏览器进程发送“确认提交”消息，这是告诉浏览器进程：已经准备好接受和解析页面数据了。
    -   浏览器进程接收到 “确认提交”消息后，便开始移除之前的旧的文档(页面)，然后更新浏览器进程中的页面状态(导航，标签页状态)。
    -   上面这些过程，从输入 URL 到开始解析的这个过程，就叫做导航。
-   从输入 URL 到页面展示
    1. 用户输入
        - 当用户在地址栏输入内容后，浏览器会判断输入的内容是 URL，还是搜索内容。
            - 如果是搜索内容，则浏览器会使用默认的搜索引擎，来合成新的带搜索内容的 URL
            - 如果是符合 URL 规则的内容，那么浏览器会将该内容合称为完整的 URL 进行网络请求
                - 如果输入内容是`time.geekbang.org`，符合 URL 规则，那么浏览器会添加上`https`协议，合成完整的 URL。
        - 当用户输入并回车后，这意味着当面页面要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面执行一次 beforeUnload 事件的机会。
            - 该事件可以取消导航，让浏览器不再执行任何后续操作。
            - 该事件可以用于询问用户是否要离开当前页面，可以用来离开之前执行一些数据清理操作。
        - 当用户没有监听 beforeUnload 事件或者同意了继续后续流程后，那么浏览器的状态栏便进入了加载状态，页面在等待提交文档阶段，页面内容才会被替换。
    2. URL 请求过程
       浏览器主进程会通过 IPC(进程间通信) 把 URL 请求发送给网络进程，然后网络进程发起真正的请求。
        - 首先 网络进程会查找本地缓存，如果命中缓存，则直接返回资源给浏览器进程，否则进入网络请求流程
        - 请求第一步是进行 DNS 解析，以获取域名对应的 IP 地址，如果请求协议是 HTTPS，则还需要建立 TLS 连接
        - 接下来就是利用 IP 地址和服务器建立 TCP 连接。
        - 建立连接后，浏览器会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。
        - 服务器接收到请求信息后，会根据请求信息生成响应数据，并发给网络进程。等网络进程接收了响应数据后，就开始解析响应头的内容了。
        - 这里会解析响应头的中的状态码，
            - 重定向：如果发现状态码是 301 或 302，那说明服务器需要浏览器重定向到其他 URL，这时网络进程会从响应头中的 Location 字段读取重定向的地址，重头开始了。
        - 响应数据类型处理
            - URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，那么浏览器会通过**Content-Type**来区别资源类型。
                - 如果 Content-Type 的值是：application/octet-stream，表明数据时字节流类型，通常情况下，浏览器会按照下载类型来处理该进程。
                - 如果一个类型被判断为下载类型，则该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就到此结束了。
                - 如果是 `Content-Type: text/HTML`，则是告诉浏览器，这是一个 HTML 文件
        - 如果资源是 HTML，则接下来就会进入到页面渲染，在 Chrome 中，那就是渲染进程的工作了，故接下来就是准备渲染进程了。
    3. 准备渲染进程
        - 一般来说，一个页面会分配一个渲染进程。
        - Chrome 的默认策略是：每个标签对应一个渲染进程，但如果从一个页面打开了新页面，且两个页面属于同一站点的话，那么新的页面会复用前者的渲染进程
            - 同一站点：相同协议，相同根域名。根域名是一二级域名组成，如：`geekbang.org`, `google.com`
        - 渲染进程准备好以后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。
    4. 提交文档
        - 指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程如下
            - 浏览器主进程接收到网络进程的响应头数据之后，给渲染进程发送“提交文档”消息
            - 渲染进程开始与网络进程建立进程间的数据管道，传输数据
            - 完成传输之后，渲染进程会给浏览器进程发送“确认提交”消息
            - 浏览器进程接收到之后，开始更新浏览器界面状态，包括：安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。
              ![](https://raw.githubusercontent.com/bran-nie/blog_images/images/20220213163235.png)
        - 这也解释了为何浏览器的地址栏输入一个地址并回车后，之前的页面没有立马消失，而是需要加载一会才会更新页面。
        - 到这里，一个完整的导航流程就走完了，接下来就是渲染阶段了。
    5. 渲染阶段
        - 一旦文档被提交，渲染进程便开始页面解析和子资源加载了。
        - 一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器进程收到后，会停止标签图标的加载动画。
